# CONTEXT (Craftsman)

Этот файл — сжатая “память проекта” для быстрого входа нового агента/разработчика в контекст: что мы делаем, какие ограничения MVP, что уже решено и куда двигаться дальше.

## Как использовать (чтобы была “память” между аккаунтами)
- Этот репозиторий — единственный источник “постоянной памяти” для будущих агентов: у модели нет гарантированной памяти между сессиями/аккаунтами.
- Держите `docs/CONTEXT.md` коротким: только устойчивые договорённости, ограничения, текущее состояние и ближайшие шаги.
- Для истории изменений используйте `docs/WORKLOG.md` (короткие пункты по датам). Туда же можно добавлять важные решения из переписок (не обязательно только про код).
- Не вставляйте сюда длинные логи чата целиком: лучше 3–10 буллетов “что решили / почему / что дальше”.
- Для новых задач используйте “Spec‑Lite” процесс и шаблоны: `docs/PROCESS.md` и `docs/templates/*`.
- Для передачи контекста между агентами используйте `npm run brain:handoff` (генерирует `docs/HANDOFF.md`).
- При смене аккаунта/агента: в первом сообщении достаточно попросить “прочитай `docs/HANDOFF.md` и следуй `docs/PROCESS.md`”.

## Протокол отклонений от плана (как мы “не уезжаем в сторону”)
Когда появляется новая идея/задача, которая не укладывается в текущий план, действуем так:
- Я помечаю это как **отклонение** и кратко объясняю риск (регрессии, усложнение, не соответствует README/ТЗ, трогает ядро, добавляет зависимости, нарушает оффлайн/.txt).
- Я предлагаю 3 пути на выбор:
  1) **Остаться в плане** (самый безопасный путь).
  2) **Минимальный компромисс** (маленький шаг, который частично решает проблему без большой перестройки).
  3) **Перепланировать** (что выкидываем/что добавляем, какие риски и проверки).
- Любые изменения “ядра” (редактор/рендер/сохранение/undo) делаем **только этапами** с ручной проверкой после каждого этапа.
- Итоговое решение (что выбрали и почему) фиксируем 2–5 буллетами в `docs/WORKLOG.md`.

Контрольные вопросы перед поворотом:
- Это точно нужно для MVP сейчас?
- Что именно рискуем сломать?
- Есть ли путь проще (без новой архитектуры/зависимостей)?
- Какие 2–3 проверки подтвердят, что не регресснули?

## Проект
- Название: `craftsman` (десктоп‑редактор для писателей)
- Технологии: Electron + vanilla HTML/CSS/JS
- Режим: полностью оффлайн
- Данные: простой текст `.txt`
- Хранение: локально на компьютере пользователя
- Бэкапы: обязательные локальные автосоздаваемые бэкапы

## Ключевые правила (MVP)
- Никаких аккаунтов/авторизации
- Никаких сетевых запросов/облаков/синхронизаций
- Минимум зависимостей и “архитектуры на будущее”
- Любые крупные изменения — поэтапно, с минимальным риском регрессий

## Перспектива (после MVP)
Зафиксированное видение (2026-01-23). Это **не** меняет ограничения MVP и не оправдывает “архитектуру на будущее” в текущем коде — только ориентир.

- Аудитория: автор + широкая аудитория.
- Платформы (возможная последовательность): довести macOS до “идеала” → web‑версия → мобильная версия → остальные платформы (Windows/Linux/Android/iOS).
- После MVP: сеть/облако/синхронизация → аккаунты → совместное редактирование (как в Google Docs).
- Экспорт: несколько форматов (после MVP).
- Масштаб текста: от 1 страницы до ~1000+; избегаем искусственных ограничений.
- Формат работы с файлами: один файл или много файлов — выбирается пользователем в настройках (после MVP / уточнить UX).
- Структура “проект/книга” в sidebar — опционально; планируются интеллект‑карты/майнд‑мэпы.

Ближайшие функциональные цели (MVP+):
- Глобальный поиск по проекту/документам — нужен уже на этапе MVP.
- История версий документа — нужна (точный объём/UX уточнить).
- Метрики/прогресс письма: цели, тайминг активности, средняя скорость печати (и т.п.).

## UI/UX договорённости
### Рамки/разделители
- Рамка “страницы” `.editor-panel` должна совпадать по толщине/цвету с разделителем sidebar.
- Для этого рамка `.editor-panel` использует `var(--sidebar-border)` (и в светлой, и в тёмной теме через переопределение переменной).

### Toolbar: режимы `min/max`
- Кнопка `min/max` должна находиться в общем потоке тулбара (без “пустого растяжения” справа).
- По клику переключает компактный/полный режим тулбара, меняет текст `min` ⇄ `max`.
- В компактном режиме остаются только “минимальные” контролы (new + font/weight/size + line-height + кнопка), остальное скрыто.

## Стили текста (Markdown‑like) — текущий подход
### Цель
- Маркеры стилей сохраняются в `.txt` (Markdown‑like префиксы/обёртки).
- При этом пользователь должен видеть визуальный стиль (заголовки, цитаты, code block, центрирование и т.п.), а не только маркеры.

### Техническое ограничение
- `textarea` не умеет частично стилизовать текст → нужен `contenteditable` и свой рендер (или отдельный preview; в MVP выбран вариант `contenteditable`).

### Выбранный вариант (MVP)
- `textarea#editor` заменён на `div#editor[contenteditable]`.
- Источник правды: plain text с маркерами.
- Рендер: строим DOM со строками/классами по маркерам и приглушёнными маркерами.
- Вставка: `paste` должен вставлять только `text/plain` (без HTML).
- Важно: курсор/выделение должны сохраняться после перерендера по offset в plain text.

## Текущее состояние реализации (на 2026-01-23)
### Сделано
- Перевод редактора на `contenteditable` + базовые хелперы: чтение/запись plain text, маппинг caret offsets, обработка Enter/paste.
- Добавлен первичный рендер “paragraph styles” по префиксам строк + code fences:
  - `#`, `##`, `###`, `>`, `::caption::`, `::center::`, `::verse::`, `—`, и fences ``` для code block.
- Добавлены CSS‑переменные и стили (параграфные): размеры/веса/отступы, приглушение маркеров, code block фон/рамка.

### Не завершено (важно)
- Inline стили (character styles) в отображении: `*...*` и `` `...` `` должны визуально выделяться (курсив/моно‑чип), при этом маркеры остаются видимыми, но приглушёнными.
- Стабильность undo/redo: перерисовка DOM может ломать нативный undo; если так — нужен простой undo‑стек (plain text + caret offsets).
- Производительность/лаг при наборе: рендер на каждый `input` нужно держать максимально дешёвым.

## Референсы и лицензии
- Можно использовать сторонние open‑source редакторы как референс архитектуры/идей.
- Важно: KDE/ghostwriter вероятно под GPL → прямое копирование кода в проект недопустимо, если проект не готов принимать GPL. Лучше фиксировать идеи/паттерны в заметках.

## Следующие шаги (приоритет)
1) Inline‑рендер `*...*` и `` `...` `` (без скрытия маркеров, но с приглушением).
2) Проверить undo/redo; при необходимости внедрить undo‑стек.
3) Уточнить/довести визуальные параметры под референсы (светлая/тёмная тема).
4) Прогнать ручные проверки из ТЗ: стили, курсор, сохранение/открытие, вставка, производительность.
